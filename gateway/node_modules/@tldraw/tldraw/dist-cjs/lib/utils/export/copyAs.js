"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var copyAs_exports = {};
__export(copyAs_exports, {
  copyAs: () => copyAs
});
module.exports = __toCommonJS(copyAs_exports);
var import_export = require("./export");
function copyAs(editor, ids, format = "svg", opts = {}) {
  const write = window.navigator.clipboard?.write;
  return editor.getSvg(ids?.length ? ids : [...editor.currentPageShapeIds], {
    scale: 1,
    background: editor.instanceState.exportBackground,
    ...opts
  }).then((svg) => {
    if (!svg) {
      throw new Error("Could not construct SVG.");
    }
    switch (format) {
      case "svg": {
        if (window.navigator.clipboard) {
          if (write) {
            write([
              new ClipboardItem({
                "text/plain": new Blob([getSvgAsString(svg)], { type: "text/plain" })
              })
            ]);
          } else {
            fallbackWriteTextAsync(async () => getSvgAsString(svg));
          }
        }
        break;
      }
      case "jpeg":
      case "png": {
        const blobPromise = (0, import_export.getSvgAsImage)(svg, editor.environment.isSafari, {
          type: format,
          quality: 1,
          scale: 2
        }).then((blob) => {
          if (blob) {
            if (window.navigator.clipboard) {
              return blob;
            }
            throw new Error("Copy not supported");
          } else {
            throw new Error("Copy not possible");
          }
        });
        const mimeType = format === "jpeg" ? "image/jpeg" : "image/png";
        if (write) {
          write([
            new ClipboardItem({
              [mimeType]: blobPromise
            })
          ]).catch((err) => {
            if (!err.toString().match(/^TypeError: DOMString not supported/)) {
              console.error(err);
            }
            blobPromise.then((blob) => {
              window.navigator.clipboard.write([
                new ClipboardItem({
                  // Note: This needs to use the promise based approach for safari/ios to not bail on a permissions error.
                  [mimeType]: blob
                })
              ]);
            });
          });
        }
        break;
      }
      case "json": {
        const data = editor.getContentFromCurrentPage(ids);
        const jsonStr = JSON.stringify(data);
        if (write) {
          write([
            new ClipboardItem({
              "text/plain": new Blob([jsonStr], { type: "text/plain" })
            })
          ]);
        } else {
          fallbackWriteTextAsync(async () => jsonStr);
        }
        break;
      }
      default:
        throw new Error(`Copy type ${format} not supported.`);
    }
  });
}
async function fallbackWriteTextAsync(getText) {
  navigator.clipboard?.writeText?.(await getText());
}
function getSvgAsString(svg) {
  const clone = svg.cloneNode(true);
  svg.setAttribute("width", +svg.getAttribute("width") + "");
  svg.setAttribute("height", +svg.getAttribute("height") + "");
  const out = new XMLSerializer().serializeToString(clone).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1");
  return out;
}
//# sourceMappingURL=copyAs.js.map
